// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sns.proto
#ifndef GRPC_sns_2eproto__INCLUDED
#define GRPC_sns_2eproto__INCLUDED

#include "sns.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace csce438 {

// The messenger service definition.
class SNSService final {
 public:
  static constexpr char const* service_full_name() {
    return "csce438.SNSService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status List(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::ListReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>> AsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>>(AsyncListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>> PrepareAsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>>(PrepareAsyncListRaw(context, request, cq));
    }
    virtual ::grpc::Status Follow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncFollowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncFollowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>> Timeline(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(TimelineRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>> AsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(AsyncTimelineRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>> PrepareAsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(PrepareAsyncTimelineRaw(context, cq));
    }
    // Slave Master interactions
    virtual ::grpc::Status PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::csce438::ServerIdent* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>> AsyncPokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>>(AsyncPokeMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>> PrepareAsyncPokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>>(PrepareAsyncPokeMasterRaw(context, request, cq));
    }
    virtual ::grpc::Status LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncLoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncLoginUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncLoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncLoginUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncFollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncFollowUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncFollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncFollowUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncTimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncTimelineUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncTimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncTimelineUpdateRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::ListReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::ListReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Timeline(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::csce438::Message,::csce438::Message>* reactor) = 0;
      // Slave Master interactions
      virtual void PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>* AsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ListReply>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>* TimelineRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>* AsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>* PrepareAsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>* AsyncPokeMasterRaw(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>* PrepareAsyncPokeMasterRaw(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncLoginUpdateRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncLoginUpdateRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncFollowUpdateRaw(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncFollowUpdateRaw(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncTimelineUpdateRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncTimelineUpdateRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Login(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    ::grpc::Status List(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::ListReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>> AsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>>(AsyncListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>> PrepareAsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>>(PrepareAsyncListRaw(context, request, cq));
    }
    ::grpc::Status Follow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncFollowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncFollowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>> Timeline(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>>(TimelineRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>> AsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>>(AsyncTimelineRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>> PrepareAsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>>(PrepareAsyncTimelineRaw(context, cq));
    }
    ::grpc::Status PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::csce438::ServerIdent* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>> AsyncPokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>>(AsyncPokeMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>> PrepareAsyncPokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>>(PrepareAsyncPokeMasterRaw(context, request, cq));
    }
    ::grpc::Status LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncLoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncLoginUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncLoginUpdate(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncLoginUpdateRaw(context, request, cq));
    }
    ::grpc::Status FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncFollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncFollowUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncFollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncFollowUpdateRaw(context, request, cq));
    }
    ::grpc::Status TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncTimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncTimelineUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncTimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncTimelineUpdateRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;
      void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::ListReply* response, std::function<void(::grpc::Status)>) override;
      void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::ListReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;
      void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Timeline(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::csce438::Message,::csce438::Message>* reactor) override;
      void PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response, std::function<void(::grpc::Status)>) override;
      void PokeMaster(::grpc::ClientContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;
      void LoginUpdate(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void FollowUpdate(::grpc::ClientContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void TimelineUpdate(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>* AsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ListReply>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>* TimelineRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* AsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* PrepareAsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>* AsyncPokeMasterRaw(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>* PrepareAsyncPokeMasterRaw(::grpc::ClientContext* context, const ::csce438::ServerIdent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncLoginUpdateRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncLoginUpdateRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncFollowUpdateRaw(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncFollowUpdateRaw(::grpc::ClientContext* context, const ::csce438::FollowData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncTimelineUpdateRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncTimelineUpdateRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Login_;
    const ::grpc::internal::RpcMethod rpcmethod_List_;
    const ::grpc::internal::RpcMethod rpcmethod_Follow_;
    const ::grpc::internal::RpcMethod rpcmethod_Timeline_;
    const ::grpc::internal::RpcMethod rpcmethod_PokeMaster_;
    const ::grpc::internal::RpcMethod rpcmethod_LoginUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_FollowUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_TimelineUpdate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);
    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::ListReply* response);
    virtual ::grpc::Status Follow(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);
    virtual ::grpc::Status Timeline(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* stream);
    // Slave Master interactions
    virtual ::grpc::Status PokeMaster(::grpc::ServerContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response);
    virtual ::grpc::Status LoginUpdate(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);
    virtual ::grpc::Status FollowUpdate(::grpc::ServerContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response);
    virtual ::grpc::Status TimelineUpdate(::grpc::ServerContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Login() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_List() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestList(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::ListReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Follow() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollow(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Timeline : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Timeline() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Timeline() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeline(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(3, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PokeMaster() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPokeMaster(::grpc::ServerContext* context, ::csce438::ServerIdent* request, ::grpc::ServerAsyncResponseWriter< ::csce438::ServerIdent>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUpdate(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowUpdate(::grpc::ServerContext* context, ::csce438::FollowData* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimelineUpdate(::grpc::ServerContext* context, ::csce438::MsgChunk* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Login<WithAsyncMethod_List<WithAsyncMethod_Follow<WithAsyncMethod_Timeline<WithAsyncMethod_PokeMaster<WithAsyncMethod_LoginUpdate<WithAsyncMethod_FollowUpdate<WithAsyncMethod_TimelineUpdate<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Login() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->Login(context, request, response); }));}
    void SetMessageAllocatorFor_Login(
        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_List() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::ListReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::ListReply* response) { return this->List(context, request, response); }));}
    void SetMessageAllocatorFor_List(
        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::ListReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::ListReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* List(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Follow() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->Follow(context, request, response); }));}
    void SetMessageAllocatorFor_Follow(
        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Follow(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Timeline : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Timeline() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackBidiHandler< ::csce438::Message, ::csce438::Message>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Timeline(context); }));
    }
    ~WithCallbackMethod_Timeline() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::csce438::Message, ::csce438::Message>* Timeline(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PokeMaster() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::ServerIdent, ::csce438::ServerIdent>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::ServerIdent* request, ::csce438::ServerIdent* response) { return this->PokeMaster(context, request, response); }));}
    void SetMessageAllocatorFor_PokeMaster(
        ::grpc::MessageAllocator< ::csce438::ServerIdent, ::csce438::ServerIdent>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::ServerIdent, ::csce438::ServerIdent>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PokeMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->LoginUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_LoginUpdate(
        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoginUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::FollowData, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::FollowData* request, ::csce438::Blep* response) { return this->FollowUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_FollowUpdate(
        ::grpc::MessageAllocator< ::csce438::FollowData, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::FollowData, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FollowUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::MsgChunk, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response) { return this->TimelineUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_TimelineUpdate(
        ::grpc::MessageAllocator< ::csce438::MsgChunk, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::MsgChunk, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TimelineUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Login<WithCallbackMethod_List<WithCallbackMethod_Follow<WithCallbackMethod_Timeline<WithCallbackMethod_PokeMaster<WithCallbackMethod_LoginUpdate<WithCallbackMethod_FollowUpdate<WithCallbackMethod_TimelineUpdate<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Login() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_List() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Follow() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Timeline : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Timeline() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Timeline() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PokeMaster() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Login() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_List() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Follow() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Timeline : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Timeline() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Timeline() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeline(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(3, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PokeMaster() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPokeMaster(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimelineUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Login() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Login(context, request, response); }));
    }
    ~WithRawCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_List() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->List(context, request, response); }));
    }
    ~WithRawCallbackMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* List(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Follow() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Follow(context, request, response); }));
    }
    ~WithRawCallbackMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Follow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Timeline : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Timeline() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Timeline(context); }));
    }
    ~WithRawCallbackMethod_Timeline() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Timeline(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PokeMaster() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PokeMaster(context, request, response); }));
    }
    ~WithRawCallbackMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PokeMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoginUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoginUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FollowUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FollowUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TimelineUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TimelineUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Login() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::Request, ::csce438::Reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::Request, ::csce438::Reply>* streamer) {
                       return this->StreamedLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_List() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::Request, ::csce438::ListReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::Request, ::csce438::ListReply>* streamer) {
                       return this->StreamedList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::ListReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::ListReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Follow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Follow() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::Request, ::csce438::Reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::Request, ::csce438::Reply>* streamer) {
                       return this->StreamedFollow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Follow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFollow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PokeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PokeMaster() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::ServerIdent, ::csce438::ServerIdent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::ServerIdent, ::csce438::ServerIdent>* streamer) {
                       return this->StreamedPokeMaster(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PokeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PokeMaster(::grpc::ServerContext* /*context*/, const ::csce438::ServerIdent* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPokeMaster(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::ServerIdent,::csce438::ServerIdent>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoginUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoginUpdate() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::Request, ::csce438::Reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::Request, ::csce438::Reply>* streamer) {
                       return this->StreamedLoginUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoginUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoginUpdate(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoginUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FollowUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FollowUpdate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::FollowData, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::FollowData, ::csce438::Blep>* streamer) {
                       return this->StreamedFollowUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FollowUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FollowUpdate(::grpc::ServerContext* /*context*/, const ::csce438::FollowData* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFollowUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::FollowData,::csce438::Blep>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TimelineUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TimelineUpdate() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::MsgChunk, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::MsgChunk, ::csce438::Blep>* streamer) {
                       return this->StreamedTimelineUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TimelineUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TimelineUpdate(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTimelineUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::MsgChunk,::csce438::Blep>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Follow<WithStreamedUnaryMethod_PokeMaster<WithStreamedUnaryMethod_LoginUpdate<WithStreamedUnaryMethod_FollowUpdate<WithStreamedUnaryMethod_TimelineUpdate<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Follow<WithStreamedUnaryMethod_PokeMaster<WithStreamedUnaryMethod_LoginUpdate<WithStreamedUnaryMethod_FollowUpdate<WithStreamedUnaryMethod_TimelineUpdate<Service > > > > > > > StreamedService;
};

// Master/Slave Interaction
class SNSSandMInform final {
 public:
  static constexpr char const* service_full_name() {
    return "csce438.SNSSandMInform";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    class async_interface {
     public:
      virtual ~async_interface() {}
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    class async final :
      public StubInterface::async_interface {
     public:
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
  };
  typedef Service AsyncService;
  typedef Service CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

// The Coordination Service definition
class SNSCoord final {
 public:
  static constexpr char const* service_full_name() {
    return "csce438.SNSCoord";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::csce438::ServerIdent* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>> AsyncClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>>(AsyncClusterSpawnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>> PrepareAsyncClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>>(PrepareAsyncClusterSpawnRaw(context, request, cq));
    }
    virtual ::grpc::Status FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncFollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncFollowerSpawnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncFollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncFollowerSpawnRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::ClusterInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>> AsyncGetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>>(AsyncGetConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>> PrepareAsyncGetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>>(PrepareAsyncGetConnectionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::FollowerInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>> AsyncGetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>>(AsyncGetFollowingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>> PrepareAsyncGetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>>(PrepareAsyncGetFollowingRaw(context, request, cq));
    }
    virtual ::grpc::Status Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::csce438::HrtBt* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>> AsyncGucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>>(AsyncGucciRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>> PrepareAsyncGucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>>(PrepareAsyncGucciRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::csce438::AllUsers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>> AsyncGetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>>(AsyncGetAllUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>> PrepareAsyncGetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>>(PrepareAsyncGetAllUsersRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>* AsyncClusterSpawnRaw(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ServerIdent>* PrepareAsyncClusterSpawnRaw(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncFollowerSpawnRaw(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncFollowerSpawnRaw(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>* AsyncGetConnectionRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::ClusterInfo>* PrepareAsyncGetConnectionRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>* AsyncGetFollowingRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::FollowerInfo>* PrepareAsyncGetFollowingRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>* AsyncGucciRaw(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::HrtBt>* PrepareAsyncGucciRaw(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>* AsyncGetAllUsersRaw(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::AllUsers>* PrepareAsyncGetAllUsersRaw(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::csce438::ServerIdent* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>> AsyncClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>>(AsyncClusterSpawnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>> PrepareAsyncClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>>(PrepareAsyncClusterSpawnRaw(context, request, cq));
    }
    ::grpc::Status FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncFollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncFollowerSpawnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncFollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncFollowerSpawnRaw(context, request, cq));
    }
    ::grpc::Status GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::ClusterInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>> AsyncGetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>>(AsyncGetConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>> PrepareAsyncGetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>>(PrepareAsyncGetConnectionRaw(context, request, cq));
    }
    ::grpc::Status GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::FollowerInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>> AsyncGetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>>(AsyncGetFollowingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>> PrepareAsyncGetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>>(PrepareAsyncGetFollowingRaw(context, request, cq));
    }
    ::grpc::Status Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::csce438::HrtBt* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>> AsyncGucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>>(AsyncGucciRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>> PrepareAsyncGucci(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>>(PrepareAsyncGucciRaw(context, request, cq));
    }
    ::grpc::Status GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::csce438::AllUsers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>> AsyncGetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>>(AsyncGetAllUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>> PrepareAsyncGetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>>(PrepareAsyncGetAllUsersRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response, std::function<void(::grpc::Status)>) override;
      void ClusterSpawn(::grpc::ClientContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void FollowerSpawn(::grpc::ClientContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response, std::function<void(::grpc::Status)>) override;
      void GetConnection(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response, std::function<void(::grpc::Status)>) override;
      void GetFollowing(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response, std::function<void(::grpc::Status)>) override;
      void Gucci(::grpc::ClientContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response, std::function<void(::grpc::Status)>) override;
      void GetAllUsers(::grpc::ClientContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>* AsyncClusterSpawnRaw(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ServerIdent>* PrepareAsyncClusterSpawnRaw(::grpc::ClientContext* context, const ::csce438::ClusterInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncFollowerSpawnRaw(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncFollowerSpawnRaw(::grpc::ClientContext* context, const ::csce438::FollowerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>* AsyncGetConnectionRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::ClusterInfo>* PrepareAsyncGetConnectionRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>* AsyncGetFollowingRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::FollowerInfo>* PrepareAsyncGetFollowingRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>* AsyncGucciRaw(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::HrtBt>* PrepareAsyncGucciRaw(::grpc::ClientContext* context, const ::csce438::HrtBt& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>* AsyncGetAllUsersRaw(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::AllUsers>* PrepareAsyncGetAllUsersRaw(::grpc::ClientContext* context, const ::csce438::Blep& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ClusterSpawn_;
    const ::grpc::internal::RpcMethod rpcmethod_FollowerSpawn_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFollowing_;
    const ::grpc::internal::RpcMethod rpcmethod_Gucci_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllUsers_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ClusterSpawn(::grpc::ServerContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response);
    virtual ::grpc::Status FollowerSpawn(::grpc::ServerContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response);
    virtual ::grpc::Status GetConnection(::grpc::ServerContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response);
    virtual ::grpc::Status GetFollowing(::grpc::ServerContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response);
    virtual ::grpc::Status Gucci(::grpc::ServerContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response);
    virtual ::grpc::Status GetAllUsers(::grpc::ServerContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClusterSpawn(::grpc::ServerContext* context, ::csce438::ClusterInfo* request, ::grpc::ServerAsyncResponseWriter< ::csce438::ServerIdent>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowerSpawn(::grpc::ServerContext* context, ::csce438::FollowerInfo* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConnection() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConnection(::grpc::ServerContext* context, ::csce438::JoinReq* request, ::grpc::ServerAsyncResponseWriter< ::csce438::ClusterInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFollowing() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFollowing(::grpc::ServerContext* context, ::csce438::JoinReq* request, ::grpc::ServerAsyncResponseWriter< ::csce438::FollowerInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Gucci() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGucci(::grpc::ServerContext* context, ::csce438::HrtBt* request, ::grpc::ServerAsyncResponseWriter< ::csce438::HrtBt>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllUsers(::grpc::ServerContext* context, ::csce438::Blep* request, ::grpc::ServerAsyncResponseWriter< ::csce438::AllUsers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ClusterSpawn<WithAsyncMethod_FollowerSpawn<WithAsyncMethod_GetConnection<WithAsyncMethod_GetFollowing<WithAsyncMethod_Gucci<WithAsyncMethod_GetAllUsers<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::ClusterInfo, ::csce438::ServerIdent>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::ClusterInfo* request, ::csce438::ServerIdent* response) { return this->ClusterSpawn(context, request, response); }));}
    void SetMessageAllocatorFor_ClusterSpawn(
        ::grpc::MessageAllocator< ::csce438::ClusterInfo, ::csce438::ServerIdent>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::ClusterInfo, ::csce438::ServerIdent>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClusterSpawn(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::FollowerInfo, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::FollowerInfo* request, ::csce438::Blep* response) { return this->FollowerSpawn(context, request, response); }));}
    void SetMessageAllocatorFor_FollowerSpawn(
        ::grpc::MessageAllocator< ::csce438::FollowerInfo, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::FollowerInfo, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FollowerSpawn(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConnection() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::ClusterInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::JoinReq* request, ::csce438::ClusterInfo* response) { return this->GetConnection(context, request, response); }));}
    void SetMessageAllocatorFor_GetConnection(
        ::grpc::MessageAllocator< ::csce438::JoinReq, ::csce438::ClusterInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::ClusterInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFollowing() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::FollowerInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::JoinReq* request, ::csce438::FollowerInfo* response) { return this->GetFollowing(context, request, response); }));}
    void SetMessageAllocatorFor_GetFollowing(
        ::grpc::MessageAllocator< ::csce438::JoinReq, ::csce438::FollowerInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::FollowerInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFollowing(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Gucci() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::HrtBt, ::csce438::HrtBt>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::HrtBt* request, ::csce438::HrtBt* response) { return this->Gucci(context, request, response); }));}
    void SetMessageAllocatorFor_Gucci(
        ::grpc::MessageAllocator< ::csce438::HrtBt, ::csce438::HrtBt>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::HrtBt, ::csce438::HrtBt>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Gucci(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Blep, ::csce438::AllUsers>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::Blep* request, ::csce438::AllUsers* response) { return this->GetAllUsers(context, request, response); }));}
    void SetMessageAllocatorFor_GetAllUsers(
        ::grpc::MessageAllocator< ::csce438::Blep, ::csce438::AllUsers>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Blep, ::csce438::AllUsers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAllUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ClusterSpawn<WithCallbackMethod_FollowerSpawn<WithCallbackMethod_GetConnection<WithCallbackMethod_GetFollowing<WithCallbackMethod_Gucci<WithCallbackMethod_GetAllUsers<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConnection() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFollowing() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Gucci() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClusterSpawn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowerSpawn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConnection() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFollowing() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFollowing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Gucci() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGucci(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClusterSpawn(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClusterSpawn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FollowerSpawn(context, request, response); }));
    }
    ~WithRawCallbackMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FollowerSpawn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConnection() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFollowing() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFollowing(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFollowing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Gucci() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Gucci(context, request, response); }));
    }
    ~WithRawCallbackMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Gucci(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAllUsers(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAllUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClusterSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClusterSpawn() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::ClusterInfo, ::csce438::ServerIdent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::ClusterInfo, ::csce438::ServerIdent>* streamer) {
                       return this->StreamedClusterSpawn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClusterSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClusterSpawn(::grpc::ServerContext* /*context*/, const ::csce438::ClusterInfo* /*request*/, ::csce438::ServerIdent* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClusterSpawn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::ClusterInfo,::csce438::ServerIdent>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FollowerSpawn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FollowerSpawn() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::FollowerInfo, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::FollowerInfo, ::csce438::Blep>* streamer) {
                       return this->StreamedFollowerSpawn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FollowerSpawn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FollowerSpawn(::grpc::ServerContext* /*context*/, const ::csce438::FollowerInfo* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFollowerSpawn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::FollowerInfo,::csce438::Blep>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConnection() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::JoinReq, ::csce438::ClusterInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::JoinReq, ::csce438::ClusterInfo>* streamer) {
                       return this->StreamedGetConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConnection(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::JoinReq,::csce438::ClusterInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFollowing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFollowing() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::JoinReq, ::csce438::FollowerInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::JoinReq, ::csce438::FollowerInfo>* streamer) {
                       return this->StreamedGetFollowing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFollowing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFollowing(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::FollowerInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFollowing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::JoinReq,::csce438::FollowerInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Gucci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Gucci() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::HrtBt, ::csce438::HrtBt>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::HrtBt, ::csce438::HrtBt>* streamer) {
                       return this->StreamedGucci(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Gucci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Gucci(::grpc::ServerContext* /*context*/, const ::csce438::HrtBt* /*request*/, ::csce438::HrtBt* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGucci(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::HrtBt,::csce438::HrtBt>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllUsers() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::Blep, ::csce438::AllUsers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::Blep, ::csce438::AllUsers>* streamer) {
                       return this->StreamedGetAllUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAllUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllUsers(::grpc::ServerContext* /*context*/, const ::csce438::Blep* /*request*/, ::csce438::AllUsers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Blep,::csce438::AllUsers>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ClusterSpawn<WithStreamedUnaryMethod_FollowerSpawn<WithStreamedUnaryMethod_GetConnection<WithStreamedUnaryMethod_GetFollowing<WithStreamedUnaryMethod_Gucci<WithStreamedUnaryMethod_GetAllUsers<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ClusterSpawn<WithStreamedUnaryMethod_FollowerSpawn<WithStreamedUnaryMethod_GetConnection<WithStreamedUnaryMethod_GetFollowing<WithStreamedUnaryMethod_Gucci<WithStreamedUnaryMethod_GetAllUsers<Service > > > > > > StreamedService;
};

class SNSFollower final {
 public:
  static constexpr char const* service_full_name() {
    return "csce438.SNSFollower";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Following(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncFollowing(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncFollowingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncFollowing(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncFollowingRaw(context, request, cq));
    }
    virtual ::grpc::Status newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncnewMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncnewMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncnewMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncnewMessageRaw(context, request, cq));
    }
    virtual ::grpc::Status newClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::Blep* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> AsyncnewClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(AsyncnewClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>> PrepareAsyncnewClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>>(PrepareAsyncnewClientRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Following(::grpc::ClientContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Following(::grpc::ClientContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void newClient(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) = 0;
      virtual void newClient(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncFollowingRaw(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncFollowingRaw(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncnewMessageRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncnewMessageRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* AsyncnewClientRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Blep>* PrepareAsyncnewClientRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Following(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncFollowing(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncFollowingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncFollowing(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncFollowingRaw(context, request, cq));
    }
    ::grpc::Status newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncnewMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncnewMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncnewMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncnewMessageRaw(context, request, cq));
    }
    ::grpc::Status newClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::csce438::Blep* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> AsyncnewClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(AsyncnewClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>> PrepareAsyncnewClient(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Blep>>(PrepareAsyncnewClientRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Following(::grpc::ClientContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void Following(::grpc::ClientContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
      void newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void newMessage(::grpc::ClientContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
      void newClient(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response, std::function<void(::grpc::Status)>) override;
      void newClient(::grpc::ClientContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncFollowingRaw(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncFollowingRaw(::grpc::ClientContext* context, const ::csce438::FollowPair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncnewMessageRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncnewMessageRaw(::grpc::ClientContext* context, const ::csce438::MsgChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* AsyncnewClientRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csce438::Blep>* PrepareAsyncnewClientRaw(::grpc::ClientContext* context, const ::csce438::JoinReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Following_;
    const ::grpc::internal::RpcMethod rpcmethod_newMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_newClient_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Following(::grpc::ServerContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response);
    virtual ::grpc::Status newMessage(::grpc::ServerContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response);
    virtual ::grpc::Status newClient(::grpc::ServerContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Following() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowing(::grpc::ServerContext* context, ::csce438::FollowPair* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_newMessage() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestnewMessage(::grpc::ServerContext* context, ::csce438::MsgChunk* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_newClient() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestnewClient(::grpc::ServerContext* context, ::csce438::JoinReq* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Blep>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Following<WithAsyncMethod_newMessage<WithAsyncMethod_newClient<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Following() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::FollowPair, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::FollowPair* request, ::csce438::Blep* response) { return this->Following(context, request, response); }));}
    void SetMessageAllocatorFor_Following(
        ::grpc::MessageAllocator< ::csce438::FollowPair, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::FollowPair, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Following(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_newMessage() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::MsgChunk, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::MsgChunk* request, ::csce438::Blep* response) { return this->newMessage(context, request, response); }));}
    void SetMessageAllocatorFor_newMessage(
        ::grpc::MessageAllocator< ::csce438::MsgChunk, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::MsgChunk, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* newMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_newClient() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::Blep>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::csce438::JoinReq* request, ::csce438::Blep* response) { return this->newClient(context, request, response); }));}
    void SetMessageAllocatorFor_newClient(
        ::grpc::MessageAllocator< ::csce438::JoinReq, ::csce438::Blep>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::JoinReq, ::csce438::Blep>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* newClient(
      ::grpc::CallbackServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Following<WithCallbackMethod_newMessage<WithCallbackMethod_newClient<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Following() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_newMessage() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_newClient() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Following() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFollowing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_newMessage() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestnewMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_newClient() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestnewClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Following() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Following(context, request, response); }));
    }
    ~WithRawCallbackMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Following(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_newMessage() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->newMessage(context, request, response); }));
    }
    ~WithRawCallbackMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* newMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_newClient() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->newClient(context, request, response); }));
    }
    ~WithRawCallbackMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* newClient(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Following : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Following() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::FollowPair, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::FollowPair, ::csce438::Blep>* streamer) {
                       return this->StreamedFollowing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Following() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Following(::grpc::ServerContext* /*context*/, const ::csce438::FollowPair* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFollowing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::FollowPair,::csce438::Blep>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_newMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_newMessage() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::MsgChunk, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::MsgChunk, ::csce438::Blep>* streamer) {
                       return this->StreamednewMessage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_newMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status newMessage(::grpc::ServerContext* /*context*/, const ::csce438::MsgChunk* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamednewMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::MsgChunk,::csce438::Blep>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_newClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_newClient() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csce438::JoinReq, ::csce438::Blep>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csce438::JoinReq, ::csce438::Blep>* streamer) {
                       return this->StreamednewClient(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_newClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status newClient(::grpc::ServerContext* /*context*/, const ::csce438::JoinReq* /*request*/, ::csce438::Blep* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamednewClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::JoinReq,::csce438::Blep>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Following<WithStreamedUnaryMethod_newMessage<WithStreamedUnaryMethod_newClient<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Following<WithStreamedUnaryMethod_newMessage<WithStreamedUnaryMethod_newClient<Service > > > StreamedService;
};

}  // namespace csce438


#endif  // GRPC_sns_2eproto__INCLUDED
